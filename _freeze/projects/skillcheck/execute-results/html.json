{
  "hash": "0e6c1ef90a71556ab6170812aa9b6f6d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Skill Check Comparison\"\nsubtitle: \"Some dice roll simulations to compare skill check mechanics from various TTRPGs\"\nauthor: \"Tobias\"\ndate: today\ndate-format: medium\nimage: \"thumbs/dice-2.jpg\"\ndraft: true\n---\n\n\n\n\n\n\n::: tldr\n**tl;dr:** I wrote this once already, then the IDE just... quit. Now I'm not inclined to repeat myself anytime soon. \\>=(\n:::\n\n# Checks from different Systems\n\nLet's take a look at some d6-based games and how they resolve their rolls:\n\n-   **Apocalypse World:** roll 2d6 and add their results; on a 10+ you succeed, on 7-9 you succeed but at a cost and on 6 or less you usually fail\n-   **Blades in the Dark:** roll several d6 (usually 1-4) based on your stats and take the single highest result; you succeed on a 6 and even gain some extra on two 6s (critical success), a 4 or 5 is a partial success similar to the above and on a 1-3 \"it's a bad outcome. Things go poorly. You probably don't achieve your goal and you suffer complications, too\"[^1]\n-   **Shadowrun:** you roll anything from 1 to 30 dice (usually about 3 to 12 though) and count all 5s, 6s (your successes) and 1s (if more than half of the rolled dice are 1s, you fail spectacularly); there are no baseline thresholds - sometimes you 'roll off' against the GM, sometimes there are rules to dictate the threshold and rather often the GM comes up with some arbitrary number you need to pass\n\n[^1]: quoted from https://bladesinthedark.com/core-system\n\nAdditionally there are ways to tinker with the results and alter the player's chances. In **AW** you sometimes flatly add (or substract) numbers to the result. **BitD** gives or takes dice to or from you and the same does **SR**, albeit with more dice.\n\nAs you can see, the first two examples are quite similar and pretty straight forward, whereas the third is a whole different kind of beast. This is why I'm writing this: I'll simulate the outcomes of the different approaches and try to find one that *feels shadowrun* but resolves in a distinct way like with the other two.\n\n## Additional Mechanics\n\nI guess? Idk yet.\n\n# Simulations\n\n\n\n\n\nThis is the interesting part. How do AW and BitD compare and how does SR fit in? I begin with sampling, oh let's just say, 2000 rolls - where 'a roll' is full skill check instead of single dice rolls. For simplicity, I only make 2000 rolls for each game once.\n\n\n::: {.cell .column-body}\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)):\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)):\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_stringMetric, as.graphicsAnnot(x$label)):\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](skillcheck_files/figure-html/plot1-1.png){width=960}\n:::\n:::\n\n\nAs we can see, the results largely scale up the same, although in *Blades in the Dark* rolls are more forgiving than in *Apocalypse World*; out otherwise, the success rates in BitD are generally a little higher. This suits the general vibes of the games: in BitD, the consequences of failing are more dire overall, therefore it's kinda fair you don't fail too easy or often. Let's take a look at *Shadowrun*, though. First at the raw number of successes (5s and 6s) and then by setting some thresholds to shoehorn everything into three success qualities.\n\n\n\n\n\n\n## Sequential Cut-Offs\n\nSince it's not possible to have 3 qualites with only one die by Shadowrun standarts (the roll is either a success or not), we'll start with 2d6:\n\n\n::: {.cell .column-body}\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](skillcheck_files/figure-html/sr_cutoffs1-1.png){width=960}\n:::\n:::\n\n\n\nOk, maybe we need to zoom in a bit.\n\n\n::: {.cell .column-body}\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\nWarning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :\nZeichensatzfamilie in der Windows Zeichensatzdatenbank nicht gefunden\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](skillcheck_files/figure-html/sr_cutoffs2-1.png){width=960}\n:::\n:::\n\n\nSeeems very much like 0/1/2, starting with 4d6, are nice cutoffs? Maybe a bit too forgiving; you could design the game around that though - it also depends on the kind of game you want to play. Anyway, let's compare:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsr_cut <- sr6 %>% \n  filter(between(dice_n, 3, 6)) %>% \n  mutate(\n    `0/1/2` = case_when(\n      result > 1 ~ \"success\",\n      result < 1 ~ \"fail\",\n      TRUE ~ \"partial\"\n    ),\n    `1/2/3` = case_when(\n      result > 2 ~ \"success\",\n      result < 2 ~ \"fail\",\n      TRUE ~ \"partial\"\n    )\n  )\n```\n:::\n\n\n## Abby's Fate\n\nThere's also a little game I helped to kickstart called **Abby's Fate**. It's not an RPG and it uses Poker Cards instead of dice, but there's an idea similar to games that are powered by the apocalypse: every character/player gets has a suit of cards - e.g. 2-Ace of Spades. They also have three abilities; a weak, a decent and a strong one. The cards they play determine the ability that gets used: 2-6, 7-10 and Jack-Ace. In numbers that looks like this:\n\nRange | _n_ cards | Percent\n------|-----------|---------\n2-6   | 5 | 0.4%\n7-10  | 4 | 0.3%\nJack-Ace | 4 | 0.3%",
    "supporting": [
      "skillcheck_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}