{
  "hash": "dfd6f0c9b24b29a4ca54d03cceba412f",
  "result": {
    "markdown": "---\ntitle: \"sth sth spotify\"\nsubtitle: \"Exploring some I wrote an R package to access the spotify API\"\ncategories: [exploration, data viz, music, data manipulation, API]\n# image: \"thumbs/diabetic.jpg\"\nauthor: \"Tobias\"\ndate: \"14. Feb, 2023\"\ndraft: true\n---\n\n\n::: tldr\n**tl;dr:** Some while ago I wrote an R package to access the spotify API. \nThe metadata on artists, albums and songs acquired that way can be used to \ngain some fun insights on your usage of that service.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.2     ✔ forcats 1.0.0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(spotifyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(SPOTIFY_CLIENT_ID = '276707abbf5d49f7a05eea84200bd42e')\nSys.setenv(SPOTIFY_CLIENT_SECRET = 'b89d30ad14364026a4ca03095c779c15')\n\nacc_tkn <- get_spotify_access_token()\n```\n:::\n\n\n# Abstract\n\nSpotify provides developers with a pretty well documented and easy to use API. \nThat way one can gain access to a sheer endless amount of mostly very well \ncurated metadata of the service's catalogue. A few years ago I wrote an R package\nto access that data in a somewhat user friendly way and to apply tidy data \nprinciples^[You know, Wickham (2014): _every column is a variable, every row is \nan observation..._] to the nested JSON datayou get from spotify. Since then, \nother packages came along that did a more thorough job and which are still \nactively maintained. First among those is certainly [`spotifyr`](https://www.rcharlie.com/spotifyr/), so we'll just go ahead and use that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblack_feat <- get_artist_audio_features(\"Black Sabbath\")\nblack_sabb <- get_artist(\"5M52tdBnJaKSvOpJGz8mfZ\")\n\nbs_albums1  <- get_artist_albums(\"5M52tdBnJaKSvOpJGz8mfZ\", limit = 50)\nbs_albums2  <- get_artist_albums(\"5M52tdBnJaKSvOpJGz8mfZ\", limit = 50, offset = 50)\nbs_albums3  <- get_artist_albums(\"5M52tdBnJaKSvOpJGz8mfZ\", limit = 50, offset = 100)\n\n\nbs_albums <- bind_rows(\n  bs_albums1,\n  bs_albums2,\n  bs_albums3\n)\n\nalbum_spec_call1 <- get_albums(bs_albums$id[1:20])\nalbum_spec_call2 <- get_albums(bs_albums$id[21:40])\nalbum_spec_call3 <- get_albums(bs_albums$id[41:60])\nalbum_spec_call4 <- get_albums(bs_albums$id[61:80])\nalbum_spec_call5 <- get_albums(bs_albums$id[81:100])\nalbum_spec_call6 <- get_albums(bs_albums$id[101:120])\nalbum_spec_call7 <- get_albums(bs_albums$id[121:140])\nalbum_spec_call8 <- get_albums(bs_albums$id[141:150])\n\nalbums_all <- bind_rows(album_spec_call1, \n                        album_spec_call2, \n                        album_spec_call3,\n                        album_spec_call4, \n                        album_spec_call5, \n                        album_spec_call6,\n                        album_spec_call7, \n                        album_spec_call8) %>% \n  mutate(\n    year = str_extract(release_date, \"[[:digit:]]{4}\") |> as.numeric()\n  ) %>% \n  filter(album_type == \"album\") %>%\n  select(name, popularity, year, id)\n\nrm(bs_albums1, bs_albums2, bs_albums3, album_spec_call1, album_spec_call2, \n   album_spec_call3, album_spec_call4, album_spec_call5, album_spec_call6,\n   album_spec_call7, album_spec_call8)\n\n# ozzy <- albums_all %>% \n#   filter(year < 1980) %>% \n#   select(album_type, name, popularity, year)\n# dio  <- albums_all %>% \n#   filter(year > 1979) %>% \n#   select(album_type, name, popularity, year)\n\n# x <- tibble(\n#     frontman = c(rep(\"Ozzy\", nrow(ozzy)), \n#                  rep(\"Dio\", nrow(dio))),\n#     popularity = c(ozzy$popularity, dio$popularity)\n# )\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Maybe Mistfits: Danzig or no Danzig?\n\n\n## Sepultura vs. Soulfly\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsepultura <- get_artist_audio_features(\"Sepultura\")\nsoulfly   <- get_artist_audio_features(\"Soulfly\")\n\nsep_album_ids  <- unique(sepultura$album_id)\nsoul_album_ids <- unique(soulfly$album_id)\n\nsep_albums1  <- get_albums(sep_album_ids[1:20])\nsep_albums2  <- get_albums(sep_album_ids[21:40])\nsep_albums3  <- get_albums(sep_album_ids[41:57])\nsoul_albums1 <- get_albums(soul_album_ids[1:20])\nsoul_albums2 <- get_albums(soul_album_ids[21:27])\n\nmaxnomax <- bind_rows(\n  sep_albums1, sep_albums2, sep_albums3,\n  soul_albums1, soul_albums2\n) %>% \n  mutate(\n    artist = map_chr(seq(n()), ~ artists[[.x]]$name),\n    year = str_extract(release_date, \"[[:digit:]]{4}\") |> as.numeric()\n  ) %>% \n  select(artist, year, name, popularity, type, label)\n```\n:::\n\n\nI really don't see a reason why anything other than the single most popular release of an album should be picked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxnomax %>% \n    group_by(name) %>% \n    summarise(\n        n = n(),\n        min = min(popularity),\n        mean = mean(popularity),\n        max = max(popularity)\n        ) %>% filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 19 × 5\n   name                                                      n   min  mean   max\n   <chr>                                                 <int> <int> <dbl> <int>\n 1 A-Lex                                                     3     0  14      22\n 2 A-Lex (2021 - Remaster)                                   2     0   9      18\n 3 Conquer                                                   3     6  14      29\n 4 Dante XXI                                                 2     1  15.5    30\n 5 Dante XXI (2021 - Remaster)                               2     0  11.5    23\n 6 Kairos                                                    4     4  29.2    45\n 7 Live at Dynamo Open Air 1998                              2     1  10.5    20\n 8 Live in São Paulo                                         2     0  10.5    21\n 9 Live in São Paulo (2022 - Remaster)                       2     0  12      24\n10 Machine Messiah                                           3    12  24.7    32\n11 Quadra                                                    4     5  24      38\n12 Revolusongs (2021 - Remaster)                             2     0  13      26\n13 Roorback                                                  2     1  16      31\n14 Roorback (2021 - Remaster)                                2     0  10      20\n15 Roots                                                     2    27  43.5    60\n16 Schizophrenia                                             2    25  31.5    38\n17 SepulQuarta                                               2    10  20.5    31\n18 Sepulquarta                                               2    13  25.5    38\n19 The Mediator Between Head and Hands Must Be the Heart     3    10  17.7    23\n```\n:::\n\n```{.r .cell-code}\nmaxdef <- maxnomax %>% \n  group_by(name) %>% \n  filter(popularity == max(popularity)) %>% \n  ungroup() %>% \n  group_by(artist, year) %>% \n  filter(popularity == max(popularity)) %>% \n  ungroup() %>% \n  mutate(\n    # maxorno = ifelse(artist == \"Soulfly\" | year > 1997, \"No Max\", \"Max\"),\n    grp = case_when(\n      artist == \"Sepultura\" & year > 1997 ~ \"Sepultura - No Max\",\n      artist == \"Soulfly\" ~ \"Soulfly\",\n      TRUE ~ \"Sepultura - Max\"\n    ) %>% as_factor()\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(afex)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLade nötiges Paket: lme4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLade nötiges Paket: Matrix\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'Matrix'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nDie folgenden Objekte sind maskiert von 'package:tidyr':\n\n    expand, pack, unpack\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n************\nWelcome to afex. For support visit: http://afex.singmann.science/\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n- Functions for ANOVAs: aov_car(), aov_ez(), and aov_4()\n- Methods for calculating p-values with mixed(): 'S', 'KR', 'LRT', and 'PB'\n- 'afex_aov' and 'mixed' objects can be passed to emmeans() for follow-up tests\n- NEWS: emmeans() for ANOVA models now uses model = 'multivariate' as default.\n- Get and set global package options with: afex_options()\n- Set orthogonal sum-to-zero contrasts globally: set_sum_contrasts()\n- For example analyses see: browseVignettes(\"afex\")\n************\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttache Paket: 'afex'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nDas folgende Objekt ist maskiert 'package:lme4':\n\n    lmer\n```\n:::\n\n```{.r .cell-code}\naov_ez(\"name\", \"popularity\", maxdef, between = \"grp\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nContrasts set to contr.sum for the following variables: grp\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nAnova Table (Type 3 tests)\n\nResponse: popularity\n  Effect    df   MSE       F  ges p.value\n1    grp 2, 30 89.43 6.03 ** .287    .006\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}